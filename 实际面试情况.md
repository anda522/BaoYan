# 杂谈

2023-6-13专业rk1和5都入了fdcs，我却中途换了工研院，这换的也太难受了吧，错过fdcs。

# 厦大

偏硬件的组

## 专业问题

- 32位，64位的地址空间

- $2^{32}$换成GB是多少，4GB

- 并行，并发，串行的区别

- 计组都学过什么？

- 对内存有什么了解

- 对缓存有什么了解

- 流水线技术

- 分页机制

- 冯诺依曼结构有哪些组成

- Linux说出几个基本的命令

## 项目问题

- Yolov5项目介绍

- 预防高空坠物及系统

## 闲聊问题

- 你能接受我们组怎么怎么样

- 你未来读研偏学术还是偏工程

- 未来是想读博还是读研

- 你认为自己比较擅长哪些

- 你未来想从事哪些方向

# 中科大

## 项目问题

- Yolov5介绍一下思路，对它了解多少
- 多场景体现在哪里
- 数据标注指的是什么，工作到底干了啥
- SVM介绍一下思路，升降维的操作，以及为什么PCA能够做到降维操作（为什么能够保留大部分的信息）

## 闲聊问题

- 如何选到徐老师的，对徐老师有什么了解，知道徐老师是做什么方向的吗
- 如何平衡学习竞赛休息
- 作息怎么样
- 有什么爱好
- 自己相对本专业的人有何优势
- ACM对自己有什么帮助
- 为什么选择机器学习的方向

# 天大

## 项目问题

- 目标检测算法都有哪些？
- SVM只能做二分类吗？
- 用R-CNN输出的特征输入进SVM进行目标检测可行吗

> 是的，将R-CNN输出的特征输入进支持向量机（SVM）进行目标检测是可行的。这种方法被称为"基于特征的目标检测"（feature-based object detection），它的基本思想是使用深度学习模型（如R-CNN）提取图像中的特征，然后将特征向量输入到SVM或其他分类器中进行分类。
>
> 在这种方法中，R-CNN通常用于提取图像中的候选对象，然后对每个候选对象提取特征，并将其转换为固定长度的特征向量。这些特征向量可以被视为输入数据，并传递到SVM或其他分类器中进行分类，以确定它们是否属于特定的目标类别。
>
> 这种方法的优点是特征提取和分类的步骤是分开的，因此可以使用不同的模型进行特征提取和分类。此外，R-CNN可以产生高质量的候选对象，因此可以减少SVM需要处理的数据量，提高检测速度。
>
> 尽管这种方法已经被证明是有效的，但它的性能通常不如端到端的深度学习模型，因为特征提取和分类是分开进行的，并且可能会导致信息丢失。因此，在目标检测中，现在更常用的方法是使用端到端的深度学习模型，如YOLO、SSD和Faster R-CNN。

# 北航

## 机试

### 1

一堆手机连接基站的记录，记录中包含手机号，连接站点（一个字母），接入时间，离开时间（221100代表22时11分00秒）。然后再给一个手机号，求与手机号连接基站时间相交的时间和，以秒计。

### 2

模拟一个函数系统。函数只有定义和调用两种情况，函数定义后是一个表达式。函数参数为一个小写字母，参数实参为整数。最后以exit结尾。调用函数时请输出对应结果，保留两位小数，之间可能有许多无用的空格。

如：

```cpp
输入：
def vary( x , y) = (x + y) / 2
vary (2, 3)
exit
输出：
2.50
```

赛后代码

```cpp
#include<bits/stdc++.h>
using namespace std;

map<string, string> func;
map<string, vector<char>> para;
map<string, vector<int>> para_val;
map<char, int> g;

double calc(char op, double x, double y) {
	if (op == '/') return x / y;
	if (op == '*') return x * y;
	if (op == '+') return x + y;
	if (op == '-') return x - y; 
}
double work(string s) {
	string f = func[s];
	
//	cout << f << " \n";
	stack<double> num;
	stack<char> op;
	
	int val = 0;
	bool is_val = 0;
	for (int i = 0; i < int(f.size()); i++) {
		if (f[i] >= '0' && f[i] <= '9') {
			val = val * 10 + f[i] - '0';
			is_val = 1;
			
		} else if (f[i] >= 'a' && f[i] <= 'z') {
			num.push(g[f[i]]);
//			cerr << "val : " << g[f[i]] << " \n";
		} else {
			if (f[i] == '(') {
				op.push(f[i]);
			} else {
				if (is_val) {
//					cerr << "val : " << val << "\n";
					num.push(val);
					val = 0;
					is_val = 0;
				}
				
				if (f[i] == '+' || f[i] == '-') {
					while (!op.empty() && (op.top() == '/' || op.top() == '*')) {
						double b = num.top();
						num.pop();
						double a = num.top();
						num.pop();
						char c = op.top();
						op.pop();
						double tmp = calc(c, a, b);
						num.push(tmp);
//						cerr << a << " " << c << " " << b << " = " << tmp << "\n";
					}
					op.push(f[i]);
				} else if (f[i] == '/' || f[i] == '*') {
					op.push(f[i]);
				} else {
					while (op.top() != '(') {
						double b = num.top();
						num.pop();
						double a = num.top();
						num.pop();
						char c = op.top();
						op.pop();
						double tmp = calc(c, a, b);
						num.push(tmp);
//						cerr << a << " " << c << " " << b << " = " << tmp << "\n";			
					}
					op.pop();
				}
			}
		}
	}
	if (is_val) {
//		cerr << "val : " << val << "\n";
		num.push(val);
		val = 0;
		is_val = 0;
	}
	while (!op.empty()) {
		double b = num.top();
		num.pop();
		double a = num.top();
		num.pop();
		char c = op.top();
		op.pop();
		double tmp = calc(c, a, b);
		num.push(tmp);
//		cerr << a << " " << c << " " << b << " = " << tmp << "\n";
	}
	return num.top();
}

int main() {
	while (true) {
		string s;
		getline(cin, s);
		if (s == "exit") break;
		
		if (s.size() >= 5 && s.substr(0, 4) == "def ") {
			string func_name;
			int pos = 3;
			while (s[pos] != '(') {
				if (s[pos] != ' ') {
					func_name += s[pos];
				}
				pos++;
			}
			pos++;
			
//			cerr << func_name << " :";
			
			char para_name;
			while (true) {
				if (s[pos] == ')') {
					para[func_name].push_back(para_name);
					pos++;
					break;
				} else if (s[pos] == ',') {
					para[func_name].push_back(para_name);
				} else {
					if (s[pos] != ' ') {
						para_name = s[pos];
					}
				}
				pos++;
			}
			
//			for (auto v : para[func_name]) {
//				cerr << v << " ";
//			}
			
			string op;
			while (pos < int(s.size())) {
				if (s[pos] != ' ' && s[pos] != '=') {
					op += s[pos];
				}
				pos++;
			}
			func[func_name] = op;
			
//			cerr << op << "\n";
			
		} else {
			string func_name;
			int pos = 0;
			while (true) {
				if (s[pos] == '(') {
					pos++;
					break;
				}
				if (s[pos] != ' ') {
					func_name += s[pos];
				}
				pos++;
			}
			
//			cerr << func_name << " : ";
			
			para_val[func_name].clear();
			
			int val = 0;
			while (true) {
				if (s[pos] == ' ' || s[pos] == '(') {
					pos++;
					continue;
				}
				if (s[pos] == ')') {
					para_val[func_name].push_back(val);
					break;
				}
				
				if (s[pos] == ',') {
					para_val[func_name].push_back(val);
					val = 0;
				} else {
					val = val * 10 + s[pos] - '0';
				}
				pos++;
			}
			
//			for (auto v : para_val[func_name]) {
//				cerr << v << ",";
//			}
//			cout << " \n";
			
			for (int i = 0; i < int(para[func_name].size()); i++) {
				g[para[func_name][i]] = para_val[func_name][i];
			}
//			for (auto bind : g) {
//				cout << bind.first << " : " << bind.second << "\n";
//			}
			
			double ans = work(func_name);
			cout << fixed << setprecision(2) << ans << "\n"; 
		}
				
	}
	return 0;
}
/*
def d(x, y  , z)  = x + y + (z - 2) * 3
d (1, 2, 3)
exit
*/
```

## 面试

读承诺书，抽政治题回答，抽一张英语文章，读完之后并翻译。（天文学翻译成占星学了，让老师笑了好一会）

数学：

高数：泰勒展开是什么？一般是几阶展开？（不会啊）为什么？

概率论：说一下全概率公式和贝叶斯公式。为什么有了全概率还要有贝叶斯公式呢？

专业课：

计组：说一下缓存。说一下缓存的换入换出策略（又让说LRU的英语，我忘了啊）。说一下缓存的映射方式（直接映射，全相连，组相连），并说一下三种方式之间的关系（我没说出来啊）。

计网：本地客户端访问纽约服务器中的一个网站的过程。OSI七层模型。

数据结构：有向图如何判断有无环。生成树的含义。最小生成树是什么。最小生成树是否唯一（本来我说的唯一，最后老师质问我，我想了一会又说不唯一并解释了原因，老师看起来不相信我了）。强连通分量是什么（可能是看我有ACM经历，忘了啊，不会）。

项目：我项目有关于Yolov5的，问了从Yolov1到v5有哪些改变，具体说一下（我没能说出来，结果老师说我看来机器学习学的也不咋样）。你做的最自豪的一个项目是啥？（我说了线程池，老师问这和机器学习有关吗，我说没关系，原来老师想问机器学习做的最自豪的一个项目，我发自内心来看真的没有自豪的项目啊，根本没时间做项目）



# 吉大计院

- 自我介绍
- 英语问题
- 专业问题：对指针和引用的理解
- 老师问题：如何平衡学习和竞赛时间



# 反问问题

- 在所有申请的人中，我的竞争力如何
- 如果之后我想进一步学习这方面的知识，推荐有哪些资源那些途径或者哪些方法去学习
